# Quill.js Delta 的核心技術結構

## 選擇 Quill.js 的時機

- 你想打造一個現代化、不依賴 jQuery 的應用程式
- 你的專案需要即時協作功能
- 你需要對編輯器的內容和行為有高度的控制權和客製化能力
- 你的應用程式是一個單頁應用 (SPA)，使用 React、Vue、Svelte 等現代框架

主要是因為它強大的 **Delta 資料模型**，讓處理和同步多使用者的內容變化變得簡單而可靠。

## 什麼是 Delta？一個簡單的比喻

你可以把 Delta 想像成一份 **「編輯說明書」或「操作紀錄」**，而不是最終的成品（文件本身）。

- **傳統的 HTML 儲存方式**：就像是直接拍下一張文件的 **「最終照片」**。它告訴你文件「長什麼樣子」，但你很難知道它是如何從一張白紙變成現在這個樣子的。
- **Delta 模型**：它不儲存「最終照片」，而是記錄下達成這個結果的每一步 **「操作指令」**。例如「在開頭插入『Hello』」、「跳過 3 個字，然後把接下來的 5 個字變粗體」、「刪除最後 2 個字」。

Delta 本質上是一個用來描述內容和內容變化的、標準化的 **JSON 資料結構**。

### Delta 的基本操作類型

Delta 主要包含三種操作：

- **insert**：插入新內容（文字或嵌入物件）
- **retain**：保留現有內容，可選擇性地應用格式
- **delete**：刪除指定長度的內容

### Delta 格式示例

```json
{
  "ops": [
    { "insert": "Hello " },
    { "insert": "World", "attributes": { "bold": true } },
    { "insert": "!" }
  ]
}
```

## 為什麼 Delta 模型這麼強大？

### 1. 為即時協作而生 (Born for Collaboration)

傳遞小塊的、描述意圖的 Delta 指令，遠比傳遞整個巨大的 HTML 字串要高效和可靠。後端伺服器（使用 OT 或 CRDT 演算法）可以輕易地理解、合併和轉換來自不同使用者的 Delta 指令，解決衝突。

> **註解**：OT (Operational Transformation) 和 CRDT (Conflict-free Replicated Data Types) 是處理即時協作衝突的演算法。

### 2. 資料結構清晰明確 (Unambiguous & Structured)

HTML 格式可能很混亂（例如 `<b><strong>文字</strong></b>`）。而 Delta 是一個非常嚴格、可預測的 JSON 結構，非常適合機器處理和轉換，不會有歧義。

### 3. 輕鬆實現歷史紀錄與 Undo/Redo

因為每一次的變更都是一個 Delta，所以要實現版本歷史或「上一步/下一步」功能，就只需要儲存和反向應用這些 Delta 物件即可。

### 4. 與後端無關 (Backend Agnostic)

它就是一個 JSON 格式。你的 Python/Django 後端、Node.js 後端或任何後端，都可以輕易地讀取和處理它，而不需要去解析複雜的 HTML。

## 總結：Delta vs. HTML

| 特性 | Delta | HTML |
| :--- | :--- | :--- |
| **本質** | 編輯指令的**紀錄** | 內容的**最終外觀** |
| **格式** | JSON | String |
| **協作** | **非常容易** | **非常困難** |
| **可控性** | **高**，API 驅動 | **低**，DOM 驅動 |
| **人類可讀性** | 較低 | 較高 |
| **機器可讀性** | **極高** | **較差**，需要解析 |

## 實際應用場景

- **即時協作編輯器**：Google Docs、Notion 等
- **版本控制系統**：追蹤文件變更歷史
- **內容管理系統**：結構化內容儲存
- **API 資料交換**：前後端之間的內容同步

---

*這就是為什麼 Quill.js 選擇 Delta 作為其核心資料模型的原因 - 它不僅解決了傳統富文本編輯器的痛點，更為現代化的協作應用奠定了堅實的技術基礎。*